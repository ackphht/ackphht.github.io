<!DOCTYPE html>
<html lang="en-US">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/>
	<title>Show Default Styles</title>
	<style type="text/css">
		table.dataTbl { border-collapse: collapse; width: 100%; margin: 0; }
		@media (min-width:768px) { table.dataTbl { max-width: 60%; } }
		table.dataTbl td, table.dataTbl th { font-size:15px; font-family:Tahoma,sans-serif; border: 1px solid darkgray; padding:6px; /*white-space: nowrap;*/ }
		/* table.dataTbl thead th { background-color: lightsteelblue; text-align: center; } */
		table.dataTbl tbody th { background-color: lavender; text-align: right; }
		table.dataTbl thead th.section { background-color: darkslateblue; color:white; text-align: center; }
		/* make main table header always visible: */
		/* div#wrapper { overflow-x: scroll;  overflow-y: scroll; max-height: 97vh; } */
		/* table#data thead th { position: sticky; top: 0; z-index: 99; } */
		table.dataTbl td ul { margin: 0;; padding-left: 1em; }
	</style>
</head>
<body>
<div id="wrapper">
	<div id="tblWrapper"></div>
	<div><button onclick="setBrowserInfo();">Refresh</button></div>
</div>

<script>
	document.addEventListener('DOMContentLoaded', setBrowserInfo);	// or window.addEventListener('load', ...), not sure which is better or if it matters
	window.addEventListener('resize', setBrowserInfo);

	async function setBrowserInfo() {
		const dataDiv = document.getElementById('tblWrapper');

		// remove any existing data:
		while (dataDiv.firstChild) { dataDiv.removeChild(dataDiv.firstChild); }

		addNavigatorInfo().render(dataDiv);
		addVisualViewportInfo().render(dataDiv);
		(await addUserAgentData()).render(dataDiv);
		addMediaQueryInfo().render(dataDiv);
	}

	class nameValue {
		constructor(n, v) { this.name = n; this.value = v; }
	}

	class nameValueRow {
		constructor() { this.nameValues = []; }
		addNameValue(nv) { this.nameValues.push(nv); }
		static fromNameValues(nvArray) {
			const result = new nameValueRow();
			if (nvArray) { for (const nv of nvArray) { result.addNameValue(nv); } }
			return result;
		}
	}

	class nameValueSection {
		constructor(sectionTitle) { this.sectionTitle = sectionTitle; this.rows = []; }
		addRow(nvRow) { this.rows.push(nvRow); }
		render(parent) {
			let tbl = make('table', parent);
			tbl.classList.add('dataTbl');
			let thead = make('thead', tbl);
			let tbody = make('tbody', tbl);
			makeSectionHeader(thead, this.sectionTitle, 6);
			for (const row of this.rows) {
				let valColSpan = -1;
				switch (row.nameValues.length) {
					case 3: valColSpan = 1; break;
					case 2: valColSpan = 2; break;
					case 1: valColSpan = 5; break;
				}
				if (valColSpan > 0) {
					const tr = make('tr', tbody);
					for (const nv of row.nameValues) {
						makeNameValueCells(tr, nv.name, nv.value, valColSpan);
					}
				}
			}
		}
	}

	function addNavigatorInfo() {
		let sect = new nameValueSection('Browser');
		sect.addRow(nameValueRow.fromNameValues([ new nameValue('UserAgent', navigator.userAgent) ]));
		sect.addRow(nameValueRow.fromNameValues([ new nameValue('Location', window.location.href) ]));
		sect.addRow(nameValueRow.fromNameValues([ new nameValue('Languages', navigator.languages) ]));
		sect.addRow(nameValueRow.fromNameValues([ new nameValue('ProcCores', navigator.hardwareConcurrency) ]));
		// not sure what this one is actualy showing:
		//sect.addRow(nameValueRow.fromNameValues([ new nameValue('Memory', navigator.deviceMemory) ]));
		// this one's not really supported:
		//sect.addRow(nameValueRow.fromNameValues([ new nameValue('NetworkType', navigator.connection.type), new nameValue('Speed', navigator.connection.downlinkMax) ]));
		sect.addRow(nameValueRow.fromNameValues([ new nameValue('Online', navigator.onLine) ]));
		return sect;
	}

	function addVisualViewportInfo() {
		let viewport = window.visualViewport;

		let sect = new nameValueSection('Display');
		sect.addRow(nameValueRow.fromNameValues([ new nameValue('ScreenWidth', window.screen.width), new nameValue('ScreenHeight', window.screen.height) ]));
		sect.addRow(nameValueRow.fromNameValues([ new nameValue('AvailWidth', window.screen.availWidth), new nameValue('AvailHeight', window.screen.availHeight) ]));
		sect.addRow(nameValueRow.fromNameValues([ new nameValue('PixelRatio', round(window.devicePixelRatio, 3)), new nameValue('Orientation', window.screen.orientation.type) ]));
		sect.addRow(nameValueRow.fromNameValues([ new nameValue('ColorDepth', window.screen.colorDepth), new nameValue('PixelDepth', window.screen.pixelDepth) ]));
		sect.addRow(nameValueRow.fromNameValues([ new nameValue('OuterWidth', window.outerWidth), new nameValue('OuterHeight', window.outerHeight) ]));
		sect.addRow(nameValueRow.fromNameValues([ new nameValue('InnerWidth', window.innerWidth), new nameValue('InnerHeight', window.innerHeight) ]));
		sect.addRow(nameValueRow.fromNameValues([ new nameValue('ViewportWidth', round(viewport.width, 2)), new nameValue('ViewportHeight', round(viewport.height, 2)) ]));
		sect.addRow(nameValueRow.fromNameValues([ new nameValue('ViewportScale', round(viewport.scale, 2)), new nameValue('', '') ]));
		return sect;
	}

	async function addUserAgentData() {
		let sect = new nameValueSection('UserAgentData [experimental]');
		if (!navigator.userAgentData) {
			sect.addRow(nameValueRow.fromNameValues([ new nameValue('UserAgentData', 'N/A') ]));
			return sect;
		}
		let data = navigator.userAgentData;
		let ul = make('ul', null);
		data.brands.forEach(b => { let li = make('li', ul); makeText(li, (b.brand + ';v=' + b.version)); });
		sect.addRow(nameValueRow.fromNameValues([ new nameValue('Brands', ul) ]));
		sect.addRow(nameValueRow.fromNameValues([ new nameValue('Platform', data.platform), new nameValue('Mobile', data.mobile) ]));

		const values = await data.getHighEntropyValues(['architecture', 'bitness', 'model', 'platformVersion', 'fullVersionList', 'uaFullVersion']);
		sect.addRow(nameValueRow.fromNameValues([ new nameValue('PlatformVersion', values.platformVersion), new nameValue('Model', values.model) ]));
		sect.addRow(nameValueRow.fromNameValues([ new nameValue('Architecture', values.architecture), new nameValue('Bitness', values.bitness) ]));
		ul = make('ul', null);
		values.fullVersionList.forEach(b => { let li = make('li', ul); makeText(li, (b.brand + ';v=' + b.version)); });
		sect.addRow(nameValueRow.fromNameValues([ new nameValue('FullVersionList', ul) ]));
		sect.addRow(nameValueRow.fromNameValues([ new nameValue('UAFullVersion [deprecated]', values.uaFullVersion), new nameValue('', '') ]));

		return sect;
	}

	function addMediaQueryInfo() {
		let sect = new nameValueSection('Media Queries');

		if (!window.matchMedia('(prefers-color-scheme)').matches) {
			sect.addRow(nameValueRow.fromNameValues([ new nameValue('prefers-color-scheme', 'N/A') ]));
		} else {
			sect.addRow(nameValueRow.fromNameValues([
				new nameValue('prefers-color-scheme', 'true'),
				new nameValue('prefers-color-scheme: light', window.matchMedia('(prefers-color-scheme: light)').matches),
				new nameValue('prefers-color-scheme: dark', window.matchMedia('(prefers-color-scheme: dark)').matches),
			]));
			;
		}

		if (!window.matchMedia('(orientation)').matches) {
			sect.addRow(nameValueRow.fromNameValues([ new nameValue('orientation', 'N/A') ]));
		} else {
			sect.addRow(nameValueRow.fromNameValues([
				new nameValue('orientation', 'true'),
				new nameValue('orientation: portrait', window.matchMedia('(orientation: portrait)').matches),
				new nameValue('orientation: landscape', window.matchMedia('(orientation: landscape)').matches),
			]));
			;
		}

		// TODO:
		//	width, min-width, height, min-height
		//	resolution (dpi)
		//	display-mode
		//	inverted-colors
		//	pointer, hover, any-pointer(?), any-hover(?)

		return sect;
	}

	function make(name, parent) {
		let e = document.createElement(name);
		if (parent) { parent.append(e); }
		return e;
	}

	function makeText(parent, value) {
		let t = document.createTextNode(value);
		parent.append(t);
	}

	function makeSectionHeader(tbody, name, desiredColumnCnt) {
		let row = make('tr', tbody);
		let th = make('th', row);
		th.colSpan = desiredColumnCnt;
		th.classList.add('section');
		makeText(th, name);
	}

	function makeNameValueCells(trow, name, value, valueColSpan) {
		th = make('th', trow);
		makeText(th, name);
		let td = make('td', trow);
		if (valueColSpan && valueColSpan > 1)
			td.colSpan = valueColSpan;
		if (typeof(value) == "string") {
			makeText(td, value);
		} else if (value instanceof HTMLElement) {
			td.append(value);
		} else {
			makeText(td, value.toString());
		}
	}

	function round(value, maxDecimalPlaces) {
		if (maxDecimalPlaces <= 0)
			return Math.round(value);
		let mult = Math.pow(10, maxDecimalPlaces) * 1.0;
		return (Math.round(value * mult) / mult);
	}
</script>
</body>
</html>
